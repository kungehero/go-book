### 数据结构底层实现及使用场景
   - [ ] 底层实现
   #### string
   ```
   sds(简单动态字符串)：根部不同的对象类型选择不同的数据结构
   1. 获取字节长度的时间复杂度O(1)
   2. 根据len的长度进行与分配内存，不用频繁的分布内存
   3. 二进制存储，数据安全，能够存储更多的数据类型
   整数类型：int
   字符串<39字节：emstr
   字符串>39字节：raw
   ```
   #### list 
   ```
   ziplist+linklist
   ziplist:压缩列表
   超过512个key，或者key大于64个字节
   linklist：双向链表
   ```
   #### hash
   ```
   ziplist+hashtable
   hashmap:相当于map 数组+双向链表(链式地址法解决哈希冲突，起始位置是随机的调用fastrand()函数，渐进式扩充)
   ```
   #### set
   ```
   
   ```
   #### zset
   - [ ] 使用场景
   ### string
   #### list
   #### hash
   #### set
   #### zset
### 持久化存储
    ### 服务重启加载数据优先级 
    ```
    aof>rdb
    ```
   - [ ] aof 
```
以追加命令的方式记录添加和更新命令
优点：数据安全，最多丢失一秒的数据
缺点：数据还原慢，占用更多的磁盘空间
```
   - [ ] rds 不阻塞线程
```
以压缩的方式进行二进制存储
优点：数据还原或回复快
缺点：数据安全性低，容易丢书数据
```
### 过期策略
   - [ ] 惰性删除
```
只有在写入或读取的时候发现设置的过期时间，已经过期才会真正的删除
优缺点：不会占用过多的内存资源耽误主线程执行操作，但是，会有大量的旧数据存在，因为有些key永远没有被访问到。
```
   - [ ] 定时删除
```
设置过期时间的key只要到了过期时间就执行过期删除
优缺点：能够最大化的是释放内存，但是，会抢占主线程的内存资源
```
   - [ ] 定期删除+惰性删除
```
每秒主动去探测设置过期时间的key，最多每秒使用250ms的时间去删除过期key，以免占用过多的内存资源耽误主线程的读写能力
主要过期策略
1.配置文件server.hz=10，代表每秒钟可以执行过期是、删除10次，每次25ms
2.不能超过空闲cpu占用的%25
```
### 淘汰机制
   - [ ] 设置过期时间
   - [ ] 所有的keys
### 缓存/数据一致性
   - [ ] 缓存
        - [ ] 缓存穿透
        - [ ] 缓存击穿
        - [ ] 缓存雪崩
   - [ ] 一致性
        - [ ] 强一致性
        - [ ] 最终一致性
### 分布式锁
   - [ ]  单点方案
   ```
   不具有单点故障容错性
   主从复制同样会出现问题：例如：当主服务获取锁之后出现了问题，开始转移从服务器，此时的锁无法进行释放二从服务器开始获得锁。
   造成主从不同步的现象
   ```
   - [ ]  集群方案
   ```
   redLock: redis distribute Lock
   1.记录当前unix时间戳
   2.尝试使用相同的K,V获取所有服务的锁，耗费的时间一定要小于ttl过期时间
   3.使用获取所有锁的时间减去(1)的时间，保证至少有三个实例获得锁
   4.如果成功，过期时间-(3)消耗时间
   5.如果失败，释放所有获得实例的锁
   ```
### 集群模式
   - [ ] 主从模式
   - [ ]  哨兵模式
   - [ ]  集群模式
### 数据倾斜
   - [ ] 原因(热点key和大key)
   - [ ] 解决方案
### 事务机制
   - [ ] 实现
   - [ ] acid特性
