### redis 线程模型
   - [ ] 文件处理
   - [ ] 事件处理
### 数据结构底层实现及使用场景
   - [ ] 底层实现
   #### string
   ```
   byte sds struct
         free int// 剩余空间
         len int// 占用的字节数
         buf [] *ptr
   }
   sds(简单动态字符串)：根部不同的对象类型选择不同的数据结构
   1. 获取字节长度的时间复杂度O(1)
   2. 根据len的长度进行与分配内存，不用频繁的分布内存
   3. 二进制存储，数据安全，能够存储更多的数据类型
   整数类型：int
   字符串<39字节：emstr
   字符串>39字节：raw
   ```
   #### list 
   ``` 
   byte list struct{
        pre *listnode
        tail *listnode
        len int
        ....
   }
   ziplist+linklist
   ziplist:压缩列表
   超过512个key，或者key大于64个字节
   linklist：双向链表
   ```
   #### hash
   ```
   byte hash struct{
         size int//哈希长度
         used int//哈希已使用的个数
         dict
   }
   
   一个哈希节点对应一个键值对
   加载因子：used/size
   
   rehash：渐进式扩缩容
   扩容条件(增量扩容 2倍)：
   1.加载因子在没有bgsave或者bgrewriteaof的情况下>大于 1
   2.加载因子在besave或者bgrewriteaof的情况下>大于 0.5
   缩容条件(等量缩容)：
   加载因子小于<0.1情况下进行缩容处理
   ziplist+hashtable
   hashmap:相当于map 数组+双向链表(链式地址法解决哈希冲突，起始位置是随机的调用fastrand()函数，渐进式扩充)
   ```
   #### set
   ```
   inset+hashtable
   
   inset:
   1.集合中所有的对象都为整数时(整数-类型可以升级，减小内存)
   2.集合中的元素数量超过512
   
   type inset struct{
        encoding uint
        length uint
        contents []int
   }
   ```
   #### zset
   ```
   ziplist:
   zbytes->ztail->zlen->entry1->entry2->...entryn->zlend
 
   entry: previous_entry_length|encoding|content
   
   主要目的为了减少内存的占用
   skiplist:
   ```
   - [ ] 使用场景
   ### string
   #### list
   #### hash
   #### set
   #### zset
### 持久化存储
    ### 服务重启加载数据优先级 
    ```
    aof>rdb
    ```
   - [ ] aof 
```
以追加命令的方式记录添加和更新命令
优点：数据安全，最多丢失一秒的数据
缺点：数据还原慢，占用更多的磁盘空间
```
   - [ ] rds 不阻塞线程
```
以压缩的方式进行二进制存储
优点：数据还原或回复快
缺点：数据安全性低，容易丢书数据
```
### 过期策略
   - [ ] 惰性删除
```
只有在写入或读取的时候发现设置的过期时间，已经过期才会真正的删除
优缺点：不会占用过多的内存资源耽误主线程执行操作，但是，会有大量的旧数据存在，因为有些key永远没有被访问到。
```
   - [ ] 定时删除
```
设置过期时间的key只要到了过期时间就执行过期删除
优缺点：能够最大化的是释放内存，但是，会抢占主线程的内存资源
```
   - [ ] 定期删除+惰性删除
```
每秒主动去探测设置过期时间的key，最多每秒使用250ms的时间去删除过期key，以免占用过多的内存资源耽误主线程的读写能力
主要过期策略
1.配置文件server.hz=10，代表每秒钟可以执行过期是、删除10次，每次25ms
2.不能超过空闲cpu占用的%25
```
### 淘汰机制
   - [ ] 设置过期时间
   - [ ] 所有的keys
### 缓存/数据一致性
   - [ ] 缓存
        - [ ] 缓存穿透
        - [ ] 缓存击穿
        - [ ] 缓存雪崩
   - [ ] 一致性
        - [ ] 强一致性
        - [ ] 最终一致性
### 分布式锁
   - [ ]  单点方案
   ```
   不具有单点故障容错性
   主从复制同样会出现问题：例如：当主服务获取锁之后出现了问题，开始转移从服务器，此时的锁无法进行释放而从服务器开始获得锁。
   造成主从不同步的现象
   ```
   - [ ]  集群方案
   ```
   redLock: redis distribute Lock
   1.记录当前unix时间戳
   2.尝试使用相同的K,V获取所有服务的锁，耗费的时间一定要小于ttl过期时间
   3.使用获取所有锁的时间减去(1)的时间，保证至少有三个实例获得锁
   4.如果成功，过期时间-(3)消耗时间
   5.如果失败，释放所有获得实例的锁
   ```
### 集群模式
   - [ ] 主从模式
   - [ ]  哨兵模式
   - [ ]  集群模式
### 数据倾斜
   - [ ] 原因(热点key和大key)
   - [ ] 解决方案
### 事务机制
   - [ ] 实现
   ```
   watch
   multi
   exec 
   discard
   ```
   - [ ] acid特性
   ```
   原子性：
   一致性：
   隔离性：
   持久化：？？？
   ```
### keys hash tag(造成数据倾斜的原因)
### 慢日志查询
```
slowlog_log_lower_than//限定毫秒级的时间为超时的指令座位慢查询
slowlog_max_length//最多可以容纳的条数
slowlog get 获取慢日志
```
